// Code generated by protoc-gen-gogo.
// source: serve.proto
// DO NOT EDIT!

/*
Package serve is a generated protocol buffer package.

It is generated from these files:
	serve.proto

It has these top-level messages:
	Artist
	Song
	Album
	EndLess
	Tree
*/
package serve

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Instrument int32

const (
	Instrument_Voice  Instrument = 0
	Instrument_Guitar Instrument = 1
	Instrument_Drum   Instrument = 2
)

var Instrument_name = map[int32]string{
	0: "Voice",
	1: "Guitar",
	2: "Drum",
}
var Instrument_value = map[string]int32{
	"Voice":  0,
	"Guitar": 1,
	"Drum":   2,
}

func (x Instrument) String() string {
	return proto.EnumName(Instrument_name, int32(x))
}

type Genre int32

const (
	Genre_Pop          Genre = 0
	Genre_Rock         Genre = 1
	Genre_Jazz         Genre = 2
	Genre_NintendoCore Genre = 3
	Genre_Indie        Genre = 4
	Genre_Punk         Genre = 5
	Genre_Dance        Genre = 6
)

var Genre_name = map[int32]string{
	0: "Pop",
	1: "Rock",
	2: "Jazz",
	3: "NintendoCore",
	4: "Indie",
	5: "Punk",
	6: "Dance",
}
var Genre_value = map[string]int32{
	"Pop":          0,
	"Rock":         1,
	"Jazz":         2,
	"NintendoCore": 3,
	"Indie":        4,
	"Punk":         5,
	"Dance":        6,
}

func (x Genre) String() string {
	return proto.EnumName(Genre_name, int32(x))
}

type Artist struct {
	// Pick something original
	Name string     `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Role Instrument `protobuf:"varint,2,opt,name=Role,proto3,enum=serve.Instrument" json:"Role,omitempty"`
}

func (m *Artist) Reset()         { *m = Artist{} }
func (m *Artist) String() string { return proto.CompactTextString(m) }
func (*Artist) ProtoMessage()    {}

type Song struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// 1,2,3,4...
	Track    uint64    `protobuf:"varint,2,opt,name=Track,proto3" json:"Track,omitempty"`
	Duration float64   `protobuf:"fixed64,3,opt,name=Duration,proto3" json:"Duration,omitempty"`
	Composer []*Artist `protobuf:"bytes,4,rep,name=Composer" json:"Composer,omitempty"`
}

func (m *Song) Reset()         { *m = Song{} }
func (m *Song) String() string { return proto.CompactTextString(m) }
func (*Song) ProtoMessage()    {}

func (m *Song) GetComposer() []*Artist {
	if m != nil {
		return m.Composer
	}
	return nil
}

type Album struct {
	// Untitled?
	Name  string  `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Song  []*Song `protobuf:"bytes,2,rep,name=Song" json:"Song,omitempty"`
	Genre Genre   `protobuf:"varint,3,opt,name=Genre,proto3,enum=serve.Genre" json:"Genre,omitempty"`
	// 2015
	Year string `protobuf:"bytes,4,opt,name=Year,proto3" json:"Year,omitempty"`
	// Uhm ja
	Producer []string `protobuf:"bytes,5,rep,name=Producer" json:"Producer,omitempty"`
	Mediocre bool     `protobuf:"varint,6,opt,name=Mediocre,proto3" json:"Mediocre,omitempty"`
	Rated    bool     `protobuf:"varint,7,opt,name=Rated,proto3" json:"Rated,omitempty"`
	Epilogue string   `protobuf:"bytes,8,opt,name=Epilogue,proto3" json:"Epilogue,omitempty"`
	Likes    []bool   `protobuf:"varint,9,rep,name=Likes" json:"Likes,omitempty"`
}

func (m *Album) Reset()         { *m = Album{} }
func (m *Album) String() string { return proto.CompactTextString(m) }
func (*Album) ProtoMessage()    {}

func (m *Album) GetSong() []*Song {
	if m != nil {
		return m.Song
	}
	return nil
}

type EndLess struct {
	Tree *Tree `protobuf:"bytes,1,opt,name=Tree" json:"Tree,omitempty"`
}

func (m *EndLess) Reset()         { *m = EndLess{} }
func (m *EndLess) String() string { return proto.CompactTextString(m) }
func (*EndLess) ProtoMessage()    {}

func (m *EndLess) GetTree() *Tree {
	if m != nil {
		return m.Tree
	}
	return nil
}

type Tree struct {
	// Types that are valid to be assigned to Stuff:
	//	*Tree_ValueString
	//	*Tree_ValueNum
	Stuff isTree_Stuff `protobuf_oneof:"stuff"`
	Left  *Tree        `protobuf:"bytes,2,opt,name=Left" json:"Left,omitempty"`
	Right *Tree        `protobuf:"bytes,3,opt,name=Right" json:"Right,omitempty"`
}

func (m *Tree) Reset()         { *m = Tree{} }
func (m *Tree) String() string { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()    {}

type isTree_Stuff interface {
	isTree_Stuff()
}

type Tree_ValueString struct {
	ValueString string `protobuf:"bytes,1,opt,name=ValueString,proto3,oneof"`
}
type Tree_ValueNum struct {
	ValueNum uint64 `protobuf:"varint,4,opt,name=ValueNum,proto3,oneof"`
}

func (*Tree_ValueString) isTree_Stuff() {}
func (*Tree_ValueNum) isTree_Stuff()    {}

func (m *Tree) GetStuff() isTree_Stuff {
	if m != nil {
		return m.Stuff
	}
	return nil
}

func (m *Tree) GetValueString() string {
	if x, ok := m.GetStuff().(*Tree_ValueString); ok {
		return x.ValueString
	}
	return ""
}

func (m *Tree) GetValueNum() uint64 {
	if x, ok := m.GetStuff().(*Tree_ValueNum); ok {
		return x.ValueNum
	}
	return 0
}

func (m *Tree) GetLeft() *Tree {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *Tree) GetRight() *Tree {
	if m != nil {
		return m.Right
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Tree) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Tree_OneofMarshaler, _Tree_OneofUnmarshaler, []interface{}{
		(*Tree_ValueString)(nil),
		(*Tree_ValueNum)(nil),
	}
}

func _Tree_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Tree)
	// stuff
	switch x := m.Stuff.(type) {
	case *Tree_ValueString:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ValueString)
	case *Tree_ValueNum:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ValueNum))
	case nil:
	default:
		return fmt.Errorf("Tree.Stuff has unexpected type %T", x)
	}
	return nil
}

func _Tree_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Tree)
	switch tag {
	case 1: // stuff.ValueString
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Stuff = &Tree_ValueString{x}
		return true, err
	case 4: // stuff.ValueNum
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Stuff = &Tree_ValueNum{x}
		return true, err
	default:
		return false, nil
	}
}

func init() {
	proto.RegisterType((*Artist)(nil), "serve.Artist")
	proto.RegisterType((*Song)(nil), "serve.Song")
	proto.RegisterType((*Album)(nil), "serve.Album")
	proto.RegisterType((*EndLess)(nil), "serve.EndLess")
	proto.RegisterType((*Tree)(nil), "serve.Tree")
	proto.RegisterEnum("serve.Instrument", Instrument_name, Instrument_value)
	proto.RegisterEnum("serve.Genre", Genre_name, Genre_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Label service

type LabelClient interface {
	Produce(ctx context.Context, in *Album, opts ...grpc.CallOption) (*Album, error)
	Loop(ctx context.Context, in *EndLess, opts ...grpc.CallOption) (*EndLess, error)
}

type labelClient struct {
	cc *grpc.ClientConn
}

func NewLabelClient(cc *grpc.ClientConn) LabelClient {
	return &labelClient{cc}
}

func (c *labelClient) Produce(ctx context.Context, in *Album, opts ...grpc.CallOption) (*Album, error) {
	out := new(Album)
	err := grpc.Invoke(ctx, "/serve.Label/Produce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *labelClient) Loop(ctx context.Context, in *EndLess, opts ...grpc.CallOption) (*EndLess, error) {
	out := new(EndLess)
	err := grpc.Invoke(ctx, "/serve.Label/Loop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Label service

type LabelServer interface {
	Produce(context.Context, *Album) (*Album, error)
	Loop(context.Context, *EndLess) (*EndLess, error)
}

func RegisterLabelServer(s *grpc.Server, srv LabelServer) {
	s.RegisterService(&_Label_serviceDesc, srv)
}

func _Label_Produce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Album)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(LabelServer).Produce(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Label_Loop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(EndLess)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(LabelServer).Loop(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Label_serviceDesc = grpc.ServiceDesc{
	ServiceName: "serve.Label",
	HandlerType: (*LabelServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Produce",
			Handler:    _Label_Produce_Handler,
		},
		{
			MethodName: "Loop",
			Handler:    _Label_Loop_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
